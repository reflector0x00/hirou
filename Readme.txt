Hirou - Ассемблер для МТ1804

Возможности:
* Asm-подобный синтаксис инструкций
* Поддержка различных типов константных чисел, в том числе: 
	* отрицательные числа
	* шестнадцатиричные числа
	* двоичные числа
* Поддержка меток
* Комментарии

Синтаксис
Каждая строчка - отдельная директива, будь то инструкция или метка.

Регистры общего назначения задаются как Ri, где i от 0 до 15. Например, R0.
Регистр PQ, соответственно, задается как RQ.

Числовые литералы:
	* Десятичные (-16, -15, ..., -1, 0, 1, ... 15)
	* Двоичные (0b0000, 0b0001, ..., 0b1111)
	* Шестнадцатиричные (0x0, 0x1, ..., 0xF)
	
Основная инструкция задается следующим образом:
aluDir R, S, L
Где aluDir - одна из микрокоманд АЛУ:
	* add = R + S
	* sub = S - R - 1
	* rsub = R - S - 1
	* or = R or S
	* and = R and S
	* rand = ~R and S
	* xor = R xor S
	* xnor = ~(R xor S)
	* addc = R + S + 1
	* subc = S - R 
	* rsubc = R - S

R и S - операнды. В соответствии со спецификацией, доступны следующие режимы:
	R(A) 	RQ
	R(A)	R(B)
	0	RQ
	0	R(B)
	0	R(A)
	D	R(A)
	D	RQ
	D	0

Здесь R(A) и R(B) - регистры с индексами A и B соответственно. 

Ввиду того, что микротренажер не поддерживает работу единовременно с 3 регистрами общего назначения, место загрузки L может быть одним из следующих:
	* 0 - нет загрузки
	* RQ
	* R(B)
	* Cдвиговый режим

Последний вариант подразумевает слово слудующего вида:
[use RQ][shift mode][shift direction][register]

Здесь
Если [use RQ] = 'q', то операции сдвига применяются так же и к RQ.
Режимы [shift mode]:
	* sh - (shift) обычный сдвиг
	* ro - (rotation) циклический сдвиг
	* dr - (double rotation) двойной циклический сдвиг
	* as - (arithmetic shift) арифметический сдвиг
Если [shift direction] = 'l', то сдвиг производится влево, если 'r', то вправо.
В качестве [register] используется один из регистров общего назначения R0 - R15.

Примеры:
	* qshlR0 - общий сдвиг влево с использованием R0
	* rorR5 - циклический сдвиг вправо регистра R5
	* qaslR14 - общий арифметический сдвиг влево с использованием R14

Переходы могут быть заданы двумя способами:
	* непосредственное использование типа перехода и (если нужно), адреса (другие операции не выполняются)
	* указание постфикса 'j' для остальных операций.
	
В последнем случае в качестве операндов еще добавляются тип перехода и, если это требуется для соответствующего перехода, адрес.
Типы перехода:
	* jnz		- по адресу, если Z = 0
    	* jmp		- по адресу, безусловный 
	* jnxt		- нет перехода
	* jadr		- по D - на данный момент не реализован
	* clnz		- по адресу, вызывает подпрограмму, если Z = 0 (помещает в стек текущий адрес)
	* call		- по адресу, вызывает подпрограмму (помещает в стек текущий адрес)
	* ret		- возврат из подпрограммы (по стеку, с извлечением)
	* jsp		- по стеку
	* jsnz		- по стеку, если Z = 1
	* push		- нет перехода, следующий помещается в стек
	* pop		- нет перехода, извлечение из стека
	* jsnc4 	- по стеку, если C4 = 0
	* jz		- по адресу, если Z = 1
	* jf3		- по адресу, если F3 = 1
	* jovr		- по адресу, если Ovr = 1
	* jc4		- по адресу, если C4 = 1

В случае, когда для операции не задан переход (отсутствует 'j' на конце), используется режим jnext 

Примеры:
	* jmp 0b0111 - безусловный переход на 0111
	* addj R1, R0, R0, jz, 15 - суммирование с переходом по Z = 1 на адрес 15
	* push - помещение следующего адреса в стек
	
Метки - способ фиксирования адресов для последующего использования в переходах. 
Нужны, чтобы ассемблер сам рассчитывал точку перехода, вне зависимости от вносимых изменений в программу.
Любая метка - это ascii-строка, не начинающаяся с цифры. 
Для объявления метки пишется ее имя с ':' на конце, в вызовах же используются как есть.

Пример цикла в 2 итерации с использованием метки "LOOP":
add 2, R0, R0
LOOP:
subc R0, 1
jnz LOOP

Так же поддерживается виртуальная инструкция nop:
	* nop 	-> and 0, 0, 0
	
В случае, если не все адреса (16) были использованы, остальные будут заполнены nop.

Комментарии задаются через ';' и до конца строки:
; Счас будет магия
add R0, R1, R1 ;Cкладываем значения двух регистров
